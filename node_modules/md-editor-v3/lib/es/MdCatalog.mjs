import { defineComponent, createVNode, reactive, shallowRef, computed, watch, onMounted, onBeforeUnmount } from "vue";
import { p as prefix } from "./chunks/config.mjs";
import { g as getRelativeTop } from "./chunks/index4.mjs";
import { b as bus, C as CATALOG_CHANGED, P as PUSH_CATALOG } from "./chunks/event-name.mjs";
const props$1 = {
  tocItem: {
    type: Object,
    default: () => ({})
  },
  mdHeadingId: {
    type: Function,
    default: () => {
    }
  },
  scrollElement: {
    type: [String, Object],
    default: ""
  },
  onClick: {
    type: Function,
    default: () => {
    }
  },
  scrollElementOffsetTop: {
    type: Number,
    default: 0
  }
};
const CatalogLink = /* @__PURE__ */ defineComponent({
  props: props$1,
  setup(props2) {
    return () => {
      const {
        tocItem,
        mdHeadingId,
        scrollElement,
        onClick,
        scrollElementOffsetTop
      } = props2;
      return createVNode("div", {
        "class": [`${prefix}-catalog-link`, tocItem.active && `${prefix}-catalog-active`],
        "onClick": (e) => {
          onClick(e, tocItem);
          e.stopPropagation();
          const id = mdHeadingId(tocItem.text, tocItem.level, tocItem.index);
          const targetHeadEle = document.getElementById(id);
          const scrollContainer = scrollElement instanceof Element ? scrollElement : document.querySelector(scrollElement);
          if (targetHeadEle && scrollContainer) {
            let par = targetHeadEle.offsetParent;
            let offsetTop = targetHeadEle.offsetTop;
            if (scrollContainer.contains(par)) {
              while (par && scrollContainer != par) {
                offsetTop += par == null ? void 0 : par.offsetTop;
                par = par == null ? void 0 : par.offsetParent;
              }
            }
            scrollContainer == null ? void 0 : scrollContainer.scrollTo({
              top: offsetTop - scrollElementOffsetTop,
              behavior: "smooth"
            });
          }
        }
      }, [createVNode("span", {
        "title": tocItem.text
      }, [tocItem.text]), createVNode("div", {
        "class": `${prefix}-catalog-wrapper`
      }, [tocItem.children && tocItem.children.map((item) => createVNode(CatalogLink, {
        "mdHeadingId": mdHeadingId,
        "key": `${tocItem.text}-link-${item.level}-${item.text}`,
        "tocItem": item,
        "scrollElement": scrollElement,
        "onClick": onClick,
        "scrollElementOffsetTop": scrollElementOffsetTop
      }, null))])]);
    };
  }
});
const CatalogLink$1 = CatalogLink;
const props = {
  /**
   * 编辑器的Id，务必与需要绑定的编辑器Id相同
   */
  editorId: {
    type: String
  },
  class: {
    type: String,
    default: ""
  },
  mdHeadingId: {
    type: Function,
    default: (text) => text
  },
  /**
   * 指定滚动的容器，选择器需带上对应的符号，默认预览框
   * 元素必须定位！！！！！！
   *
   * 默认：#md-editor-preview-wrapper
   */
  scrollElement: {
    type: [String, Object]
  },
  theme: {
    type: String,
    default: "light"
  },
  /**
   * 高亮标题相对滚动容器顶部偏移量，即距离该值时，高亮当前目录菜单项
   *
   * 默认：20px
   */
  offsetTop: {
    type: Number,
    default: 20
  },
  /**
   * 滚动区域的固定顶部高度
   *
   * 默认：0
   */
  scrollElementOffsetTop: {
    type: Number,
    default: 0
  },
  onClick: {
    type: Function
  },
  onActive: {
    type: Function
  }
};
const MdCatalog = /* @__PURE__ */ defineComponent({
  name: "MdCatalog",
  props,
  emits: ["onClick", "onActive"],
  setup(props2, ctx) {
    const editorId = props2.editorId;
    const state = reactive({
      list: [],
      show: false,
      scrollElement: props2.scrollElement || `#${editorId}-preview-wrapper`
    });
    const activeItem = shallowRef();
    const catalogs = computed(() => {
      const tocItems = [];
      state.list.forEach((listItem, index) => {
        const {
          text,
          level
        } = listItem;
        const item = {
          level,
          text,
          index: index + 1,
          active: activeItem.value === listItem
        };
        if (tocItems.length === 0) {
          tocItems.push(item);
        } else {
          let lastItem = tocItems[tocItems.length - 1];
          if (item.level > lastItem.level) {
            for (let i = lastItem.level + 1; i <= 6; i++) {
              const {
                children
              } = lastItem;
              if (!children) {
                lastItem.children = [item];
                break;
              }
              lastItem = children[children.length - 1];
              if (item.level <= lastItem.level) {
                children.push(item);
                break;
              }
            }
          } else {
            tocItems.push(item);
          }
        }
      });
      return tocItems;
    });
    const getScrollElement = () => {
      const scrollElement = state.scrollElement instanceof HTMLElement ? state.scrollElement : document.querySelector(state.scrollElement);
      return scrollElement;
    };
    const findActiveHeading = (list) => {
      if (list.length === 0) {
        state.list = [];
        return false;
      }
      const {
        activeHead
      } = list.reduce((activeData, link, index) => {
        const linkEle = document.getElementById(props2.mdHeadingId(link.text, link.level, index + 1));
        if (linkEle instanceof HTMLElement) {
          const scrollElement = getScrollElement();
          const relativeTop = getRelativeTop(linkEle, scrollElement);
          if (relativeTop < props2.offsetTop && relativeTop > activeData.minTop) {
            return {
              activeHead: link,
              minTop: relativeTop
            };
          }
        }
        return activeData;
      }, {
        activeHead: list[0],
        minTop: Number.MIN_SAFE_INTEGER
      });
      activeItem.value = activeHead;
      state.list = list;
    };
    const scrollHandler = () => {
      findActiveHeading(state.list);
    };
    watch(() => activeItem.value, (nVal) => {
      const activeHeading = nVal ? {
        ...nVal
      } : void 0;
      if (props2.onActive) {
        props2.onActive(activeHeading);
      } else {
        ctx.emit("onActive", activeHeading);
      }
    });
    onMounted(() => {
      let scrollContainer = window;
      const findScrollContainer = () => {
        const scrollElement_ = getScrollElement();
        scrollContainer = scrollElement_ === document.documentElement ? window : scrollElement_;
      };
      bus.on(editorId, {
        name: CATALOG_CHANGED,
        callback: (_list) => {
          scrollContainer == null ? void 0 : scrollContainer.removeEventListener("scroll", scrollHandler);
          findActiveHeading(_list);
          findScrollContainer();
          scrollContainer == null ? void 0 : scrollContainer.addEventListener("scroll", scrollHandler);
        }
      });
      bus.emit(editorId, PUSH_CATALOG);
      findScrollContainer();
      scrollContainer == null ? void 0 : scrollContainer.addEventListener("scroll", scrollHandler);
    });
    onBeforeUnmount(() => {
      var _a;
      const scrollElement = getScrollElement();
      (_a = scrollElement === document.documentElement ? window : scrollElement) == null ? void 0 : _a.removeEventListener("scroll", scrollHandler);
    });
    return () => createVNode("div", {
      "class": `${prefix}-catalog${props2.theme === "dark" ? "-dark" : ""} ${props2.class}`
    }, [catalogs.value.map((item) => {
      return createVNode(CatalogLink$1, {
        "mdHeadingId": props2.mdHeadingId,
        "tocItem": item,
        "key": `link-${item.level}-${item.text}`,
        "scrollElement": state.scrollElement,
        "onClick": (e, t) => {
          if (props2.onClick) {
            props2.onClick(e, t);
          } else {
            ctx.emit("onClick", e, t);
          }
        },
        "scrollElementOffsetTop": props2.scrollElementOffsetTop
      }, null);
    })]);
  }
});
MdCatalog.install = (app) => {
  app.component(MdCatalog.name, MdCatalog);
  return app;
};
export {
  MdCatalog as default
};
